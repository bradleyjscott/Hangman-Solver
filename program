#include<iostream>
#include<fstream>
#include<string>
#include<set>
#include<map>
#include<cmath>
#include<vector>

/*
SpellingAce Hangman Solver

Bradley Scott II
2020 May 14

This program is designed to solve a hangman word generated by the spellingace word game by suggesting
most probable guesses until the word is solved.

To run this program enter into command prompt:
cd documents
cd code
cd spellingace
g++ -o spellingace_hangman spellingace_hangman.cpp
spellingace_hangman

Next:
Make this program run on every word in the dictionary to see which words it solves and which it doesn't.

Make seperate files for UI and algorithm/framework.

Use a list of most common words as well as profiles for the people the program is solving for to determine
which words are more likely to be the solution to improve accuracy.
*/

//Add words from the input file to the local dictionary
std::set<std::string> add_words_if(std::string const& file, int min, int max) {
    std::ifstream word_file;
    std::string word;
    std::set<std::string> all_words {};

    word_file.open(file);
    if (!word_file.is_open()) {

        throw std::runtime_error ("Error: Unable to open input file.");

    }

    while (word_file >> word) {
        
        if(word.size() >= min && word.size() <= max) {

            if(!all_words.insert(word).second) {

                throw std::runtime_error("Error: Duplicate word in input file.");

            };
        };
    }

    word_file.close();

    return all_words;
}

//Given a word and a filename, add the word to the file
void add_to (std::string solved_word, std::string document) {
    std::ofstream word_file_out;
    std::ifstream word_file_in;
    std::string word {};
    std::vector<std::string> solved_words_file {};
    std::set<std::string> solved_words {};
    std::string doc_word_1 {};
    std::string doc_word_2 {};

    if(document == "Solved_Words.txt") {
        doc_word_1 = "solves";
        doc_word_2 = "solved";

    } else if (document == "Striked_Words.txt") {
        doc_word_1 = "strikes";
        doc_word_2 = "striked";
        
    } else {
        doc_word_1 = "unknowns";
        doc_word_2 = "unknown";

    }

    word_file_in.open(document);

    if (!word_file_in.is_open()) {

        throw std::runtime_error ("Error: Unable to open file.");

    }

    while(word_file_in >> word) {
        
        solved_words_file.push_back(word);
        
    }

    solved_words_file.push_back(solved_word);

    word_file_in.close();

    word_file_out.open(document);
    if (!word_file_out.is_open()) {

        throw std::runtime_error ("Error: Unable to open file.");

    }

    int position {};
    for(std::string word: solved_words_file) {
        
        if(position > 4) {

            solved_words.insert(word);

        }
            
        position++;
        
    }
    position = {};

    word_file_out << "Total " << doc_word_1 << ": " << std::stoi(solved_words_file.at(2)) + 1 << "\nWords " << doc_word_2 << ":\n";

    for(std::string word: solved_words) {

        word_file_out << word << "\n";

    }

    word_file_out.close();

}

//Function to terminate the program
void end () {

    std::cout << "Program terminated; thanks for playing!" << std::endl;

    exit(0);
}

//Given a set of possible words and a set of guessed letters, return the best guess letter and how many words it is in
std::pair<char, int> best_guess (std::set<std::string> possible_words, std::set<char> guessed_letters) {
    std::map<char, int> letter_frequencies {};
    std::pair<char, int> result {};
    int most_frequent_letter_value {};

    //Populate letter_frequencies map with how many words have each letter from the list of possible words
    for(std::string word: possible_words) {
        std::set<char> chars_in_word {};

        for(char C: word) {

            if(chars_in_word.find(C) == chars_in_word.end()) {

                chars_in_word.insert(C);

            }

        }

        for(char C: chars_in_word) {

            letter_frequencies[C] += 1;

        }

    }

    //Find the letter with the largest number of occurrences
    for(std::pair<char, int> pair: letter_frequencies) {

        if(guessed_letters.find(pair.first) == guessed_letters.end() && pair.second > result.second) {

            result = pair;

        }
    }


    return result;
}

//Given a word and the dictionary of possible words, check if the word is in the dictionary
bool lookup_word (std::string word, std::set<std::string> dictionary) {
    bool result {};
    
    for(std::string d_word: dictionary) {

        if(word == d_word) {
            result = true;

        }
    }

    return result;
}

int main() {
    std::vector<char> current_model_list {};
    std::string current_model {};
    int remaining_strikes {};
    std::set<char> guessed_letters {};

    int min_word_length {3};
    int max_word_length {13};
    std::set<std::string> dictinary {};
    std::set<std::string> possible_words {};
    std::string entry {};
    std::string first_word_input {};
    int solution_length {};
    std::map<char, int> letter_locations {};
    bool new_word {true};
    bool first_word {true};
    bool ignore_cin {true};
    bool after_first_word {};

    //While /end has not been entered, continue to loop through new words to solve
    while(entry != "/end") {

        //Code to run wheather a new word is started or not
        if(new_word) {
            remaining_strikes = 10;
            current_model_list = {};
            current_model = {};
            guessed_letters = {};
            
            //Code to run wheather or not this is the first word since program start
            if(first_word == true) {
                after_first_word = true;
                std::string discard_word {};
                float solved {};
                float striked {};
                float unknown {};

                std::ifstream word_file_in;

                word_file_in.open("Solved_Words.txt");
                for(int i {}; i < 3; i++) {

                    if (i == 2) {
                        
                        word_file_in >> solved;

                    } else {

                        word_file_in >> discard_word;

                    }
                    
                }
                word_file_in.close();
                word_file_in.open("Striked_Words.txt");
                for(int i {}; i < 3; i++) {

                    if (i == 2) {
                        
                        word_file_in >> striked;

                    } else {

                        word_file_in >> discard_word;

                    }
                    
                }
                word_file_in.close();
                word_file_in.open("Unknown_Words.txt");
                for(int i {}; i < 3; i++) {

                    if (i == 2) {
                        
                        word_file_in >> unknown;

                    } else {

                        word_file_in >> discard_word;

                    }
                    
                }
                word_file_in.close();

                float total_words {solved + striked + unknown};
                float percentage_solved {std::round(100*(solved/total_words))};
                std::cout << std::endl << "Welcome to the SpellingAce hangman solver by Bradley Scott II!" << std::endl
                << "This program has correctly solved " << solved << " out of " << total_words << " attempted words. (" << percentage_solved << "% success rate)" << std::endl << std::endl;

                try {

                    dictinary = add_words_if("twl06.txt", min_word_length, max_word_length);

                } catch (std::runtime_error e) {

                    std::cout << e.what() << std::endl << "Program terminated" << std::endl;
                    return 0;

                }

                std::cout << "Enter the length of the first word." << std::endl;
                std::cin >> first_word_input;
                try{

                    solution_length = std::stoi(first_word_input);

                } catch (std::invalid_argument e) {

                    end();

                }

                for(int i {}; i < solution_length; i++) {

                    current_model_list.push_back('?');

                }

                first_word = false;

            } else {

                std::cout << "Enter the length of the next word." << std::endl;
                std::cin >> first_word_input;
                std::cout << std::endl;

                try{

                    solution_length = std::stoi(first_word_input);

                } catch (std::invalid_argument e) {

                    end();

                }

                for(int i {}; i < solution_length; i++) {

                    current_model_list.push_back('?');

                }
            }

            //Warn if the user enters an invalid word length
            if(solution_length < min_word_length || solution_length > max_word_length) {

                std::cout << "You entered an invalid word length, please restart the program." << std::endl;

                end();

            }

            //Include only words of the correct size in the list of possible words
            for(std::string word: dictinary) {

                if(word.size() == solution_length) {

                    possible_words.insert(word);

                }
            }

            new_word = false;

        } else {
            std::pair<char,int> best_pair {best_guess(possible_words, guessed_letters)};
            char guess_letter {best_pair.first};
            char guessed_letter {};
            bool zero_entered {};
            entry = {};
            
            //Update current word model
            current_model = {};
            for(char C: current_model_list) {
                
                current_model.push_back(C);

            }
            
            //Text to output for every time through the loop
            float size = possible_words.size();
            float percentage {std::round(100*(best_pair.second/size))};
            if(after_first_word) {
                after_first_word = false;

                std::cout << "The current model is: " << current_model;
                std::cout << " and there are currently " << possible_words.size() << " possible solution words." << std::endl;
                std::cout << "You have " << remaining_strikes << " strikes remaining; the suggested guess is: " << best_pair.first << " (" << percentage << "% chance)" << std::endl;
                std::cout << "Enter the locations of the letter " << guess_letter << " in the word as numbers with spaces between them to update model. Example: 1 4 6" << std::endl << "Enter 0 if there are no instances of " << guess_letter << "." << std::endl;
                std::cout << "If you have guessed a different letter enter it followed by it's locations in the word. Example: b 2 7 8 or: w 0" << std::endl;
                std::cout << "Enter /end at any point during runtime to end the program." << std::endl;

            } else {

                std::cout << "Model:             " << current_model << std::endl;
                std::cout << "Possible words:    " << possible_words.size() << std::endl;
                std::cout << "Remaining strikes: " << remaining_strikes << std::endl;
                std::cout << "Best guess:        " << best_pair.first << " (" << percentage << "% chance) " << std::endl;

            }

            if (ignore_cin) {
                ignore_cin = false;

                std::cin.ignore();

            }

            //Get the line of input from user
            std::getline(std::cin, entry);
            while(entry.size() == 1 && std::isalpha(entry.at(0))) {

                std::cout << "Please enter the locations of the letter. Example: s 3 9" << std::endl;
                std::getline(std::cin, entry);

            }
            std::cout << std::endl;

            if(entry == "/end") {

                end();

            }
            
            //Determine which letter was guessed
            if(std::isalpha(entry.at(0))) {
                guessed_letter = entry.at(0);

            } else {
                guessed_letter = guess_letter;

            }
            
            //Extract integers from the input line
            std::vector<std::string> entered_numbers {};
            std::string current_number {};
            for(char C: entry) {

                if(isdigit(C)) {

                    current_number.push_back(C);

                } else if(current_number != "") {
                    
                    entered_numbers.push_back(current_number);
                    current_number = {};

                }
            }
            entered_numbers.push_back(current_number);

            for(std::string word: entered_numbers) {

                if(stoi(word) == 0) {
                    zero_entered = true;
                    
                }

                if(stoi(word) != 0) {
                    
                    current_model_list.at(stoi(word) - 1) = guessed_letter;

                }
            }
            
            //Eliminate possible words if 0 was entered, meaning that there were non of that letter in the word,
            //or eliminate words if their locations in the word are entered.
            if(zero_entered) {
                remaining_strikes--;
                bool erase_word {};
                
                //This loop has caused the program to end when the word length is 6 or above and you enter 0 for each letter guess
                auto iter5 = possible_words.begin();
                while(iter5 != possible_words.end()) {
                    
                    for(char letter: *iter5) {

                        if(letter == guessed_letter) {
                            erase_word = true;

                        }
                    }
                    
                    if(erase_word) {

                        possible_words.erase(*iter5);
                        erase_word = false;

                    }

                    iter5++;
                    
                }
                
                zero_entered = false;

            } else {
                bool erase_word {};
                int letter_index {};
                std::set<std::string> old_possible_words {possible_words};
                
                possible_words = {};
                auto iter1 = old_possible_words.begin();
                while(iter1 != old_possible_words.end()) {
                    std::string word = *iter1;
                    letter_index = 0;

                    for(char letter: word) {
                        
                        //For some reason I need this try block to cach random out of range errors from the current_model_list vector
                        try {
                            if((current_model_list.at(letter_index) != '?' && letter != current_model_list.at(letter_index)) || (current_model_list.at(letter_index) == '?' && letter == guessed_letter)) {
                                erase_word = true;

                            }
                        } catch (std::out_of_range) {
                            std::cout << "Caught out_of_range error" << std::endl;
                        }

                        letter_index++;
                    }
            
                    if(!erase_word) {

                        possible_words.insert(word);

                    }

                    erase_word = false;
                    iter1++;

                }
            }
            
            //Keep track of which letters have been guessed per word
            guessed_letters.insert(guessed_letter);

            //Code to run if the number of strikes has been reached
            if(remaining_strikes == 0 && possible_words.size() > 0) {
                std::string solution_word {};

                std::cout << "Sorry, no solution found this round." << std::endl << "Please enter the solution word." << std::endl;
                std::cin >> solution_word;
                while(solution_word.at(0) == '/') {

                     std::cout << "Cannot end program now, please enter solution word." << std::endl;
                     std::cin >> solution_word;

                }

                if(lookup_word(solution_word, dictinary)) {

                    std::cout << std::endl << "This word is in my dictionary, I just couldn't solve for it." << std::endl;
                    add_to(solution_word, "Striked_Words.txt");

                } else {
                    
                    std::cout << std::endl << "I couldn't find this word in my dictionary, I'll remember that!" << std::endl;
                    add_to(solution_word, "Unknown_Words.txt");

                }
        
                std::cout << std::endl;

                ignore_cin = true;
                new_word = true;

            }
            
            //Code to run if there is only one possible word left or if there are no possible words left
            bool deduced_word {};
            if(possible_words.size() == 1 && remaining_strikes != 0) {

                for(char letter: current_model_list) {

                    if(letter == '?') {

                        deduced_word = true;

                    }

                }

                //Code to run if the word has been deduced based off of known criteria or if every letter of the word has been found
                if(deduced_word) {

                    std::cout << "The solution word is: " << *possible_words.begin() << std::endl << "Is this correct? (y/n)" << std::endl;

                    std::cin >> entry;
                    while(entry != "y" && entry != "n") {

                        std::cout << "Cannot end prgram now, please enter 'y' for yes or 'n' for no." << std::endl;
                        std::cin >> entry;

                    }
                    std::cout << std::endl;

                    if(entry == "y") {
                        new_word = true;

                        add_to(*possible_words.begin(), "Solved_Words.txt");
                            
                    } else {
                        std::string solution_word {};

                        std::cout << "Sorry, this word may not exist in my dictionary." << std::endl << "Please enter the solution word." << std::endl;
                        std::cin >> solution_word;
                        while(solution_word.at(0) == '/') {
                            std::cout << "Cannot end program now, please enter the solution word. " << std::endl;

                            std::cin >> solution_word;

                        }

                        if(lookup_word(solution_word, dictinary)) {

                            std::cout << std::endl << "There was a mistake in entry, this word does exist in my dictionary." << std::endl;

                        } else {
                            
                            std::cout << std::endl << "I couldn't find this word in my dictionary, I'll remember that!" << std::endl;
                            add_to(solution_word, "Unknown_Words.txt");

                        }
                        
                        std::cout << std::endl;

                        ignore_cin = true;
                        new_word = true;
                        
                    }

                    ignore_cin = true;
                
                } else {

                    std::cout << "Congradulations! You solved: " << *possible_words.begin() << std::endl << std::endl;

                    add_to(*possible_words.begin(), "Solved_Words.txt");

                    ignore_cin = true;
                    new_word = true;

                }

            } else if (possible_words.size() == 0) {
                std::string solution_word {};

                std::cout << "Sorry, this word may not exist in my dictionary." << std::endl << "Please enter solution word." << std::endl;
                std::cin >> solution_word;
                while(solution_word.at(0) == '/') {

                    std::cout << "Cannot end program now, please enter solution word." << std::endl;
                    std::cin >> solution_word;

                }
                if(lookup_word(solution_word, dictinary)) {

                            std::cout << std::endl << "There was a mistake in entry, this word does exist in my dictionary." << std::endl;

                        } else {
                            
                            std::cout << std::endl << "I couldn't find this word in my dictionary, I'll remember that!" << std::endl;
                            add_to(solution_word, "Unknown_Words.txt");

                        }
                std::cout << std::endl;

                ignore_cin = true;
                new_word = true;

            }
        }
    }

    end();

}
